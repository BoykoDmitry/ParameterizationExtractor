<#@ template language="C#" #>
<#@ output extension=".cs" #>
<#@ assembly name="ParameterizationExtractor.Logic" #>
<#@ import namespace="System.Globalization" #>  
<#@ import namespace="System.Linq" #>
<#@ import namespace="System.Text" #>
<#@ import namespace="System.Collections.Generic" #>
<#@ import namespace="Quipu.ParameterizationExtractor.Logic.Model" #>
<#@ import namespace="Quipu.ParameterizationExtractor.Logic.Helpers" #>
<#@ import namespace="Quipu.ParameterizationExtractor.Logic.Interfaces" #>
<#@ import namespace="ParameterizationExtractor" #>
<#@ import namespace="System.Reflection" #>
/*
Autogenerated by excavator tool, version <#=Assembly.GetExecutingAssembly().GetName().Version.ToString()#> 
<#=DateTime.Now.ToString()#>
Source: <#=Schema.DataSource#> 
Database: <#=Schema.Database#> 
*/

GO

begin try
begin tran
<# 	
foreach (var record in Items.Where(_ => _.IsStartingPoint))
            {
#>
<#
#>
	--#region <#=record.TableName#>
<#
				//ProcessedItems = new List<PRecord>();
				ProcessOne(record, null, null);
#>
	--#endregion <#=record.TableName#>
<#
            }
#>
commit
end try
--#region catch
begin catch
	declare @Err_msg nvarchar(2048), @Err_svrt int
	select @Err_msg = isnull(error_message(), 'has not been retrieved'), @Err_svrt = error_severity();
	if @@trancount > 0 rollback;
	raiserror (@Err_msg, @Err_svrt, 1) with nowait;
end catch;
--#endregion

<#+  	
	private IList<PRecord> ProcessedItems = new List<PRecord>();

	private ISourceSchema _schema;
	private ISourceSchema Schema
	{
		get {
			_schema = _schema ?? this.Session["schema"] as ISourceSchema;

			return _schema;
		}
	} 

	private IEnumerable<PRecord> _items;
	private IEnumerable<PRecord> Items
	{
		get {
			_items = _items ?? this.Session["source"] as IEnumerable<PRecord>;

			return _items;
		}
	} 

	void ProcessOne (PRecord item, PRecord parentRecord, PDependentTable FK, IList<PRecord> moves = null )
	{
		//Console.WriteLine("Process one entry:{0}, parentRecord:{1}",item.ToString(), parentRecord?.ToString());
		moves = moves ?? new List<PRecord>();
		if (moves.Any(_=>_.Equals(item)))
		{
			//Console.WriteLine("Shit hits the fan !");
			return;
		}

		moves.Add(item);

		
		if (item.Parents.Any())
		{
			//foreach(var parent in item.Parents)
			//	Console.WriteLine("item.Parent {0}", parent.PRecord);
								
			foreach(var parent in item.Parents)
			{						
				if (!ProcessedItems.Any(_=>_.Equals(parent.PRecord))
					&& !moves.Any(_=>_.Equals(parent.PRecord))
				)
				{
					Console.WriteLine("item.Parents, parentRecord:{0}",parent.PRecord?.ToString());
					if (parent.PRecord.SqlBuildStrategy.NoInserts)
					{
						if (parent.PRecord.SqlBuildStrategy.ThrowExecptionIfNotExists)
						{
							IfNotExists(parent.PRecord);
							#>
		RAISERROR('Record from table <#=parent.PRecord.TableName#> with unique values <#=SqlHelper.GetNameNormalValueString(parent.PRecord.GetUniqueFields())#> can not be found', 16, 1) 
<#+
						}

						GenerateSqlForNoExtractionTable(parent.PRecord);						
					}
					else
					{
						//Console.WriteLine("I am going to print GenerateSqlForParent, parentRecord:{0} item {1}",parent.PRecord?.ToString(), item);						
						GenerateSqlForParent(parent.PRecord);						
					}
						
					//foreach(var c in parent.PRecord.Childern)
						//Console.WriteLine("parent.PRecord.Childern {0}", c.PRecord);

					foreach(var c in parent.PRecord.Childern.Where(_=>!moves.Any(t=>t.Equals(_.PRecord))))
					{
						//Console.WriteLine("Process parent children:{0}, parentRecord:{1}",c.PRecord.ToString(), parent.PRecord?.ToString());
						ProcessOne (c.PRecord, parent.PRecord, c.FK,moves);
					}
				}

				SqlHelper.PrepareFieldsForChild(item, parent.PRecord.GetPKVarName(), parent.FK);				
			}
		}

		if (parentRecord != null && FK != null)
			SqlHelper.PrepareFieldsForChild(item, parentRecord.GetPKVarName(), FK);


		GenerateSql(item,parentRecord,FK);

		foreach (var child in item.Childern.Where(_=>!moves.Any(t=>t.Equals(_.PRecord))))
		{
            ProcessOne(child.PRecord, item, child.FK, moves);
			Write("\n");
		}
	}

	void InsertValues(IEnumerable<PField> fields, string tableName)
	{
#>
		insert into <#=tableName#> (<#+Write(string.Join(",",fields.Select(_=>string.Format("[{0}]",_.FieldName))));#>) 
		values (<#=string.Join(",",fields.Select(_=>_.ValueToSqlString()))#>)
<#+
	}

	void IfNotExists(PRecord table)
	{
		if (!string.IsNullOrEmpty(table.GetUniqueSqlWhere()))
		{
#>
		if not exists(select * from <#=string.Format("{0} where {1}",table.TableName,table.GetUniqueSqlWhere())#> )				
<#+		}
	else #> 
	-- here should be something like if not exists, but unique columns(or values) can not be found. 
<#+
	}
    
    void GenerateSqlForNoExtractionTable(PRecord parent)
	{
		if (!ProcessedItems.Any(_=>_.Equals(parent)))
			{
	#>
		declare <#=string.Format("{0} {1}\n",parent.GetPKVarName(), parent.PkField.MetaData.SqlType)#> 
		select <#=parent.GetPKVarName()#> = <#=parent.PkField.FieldName#> 
		from  <#=parent.TableName#>  
		where <#=parent.GetUniqueSqlWhere()#>
<#+
		ProcessedItems.Add(parent);
		}		
	}

	void GenerateSqlForParent(PRecord parent)
	{
		if (!parent.GetUniqueFields().Any())
			Error("Can not generate sql without PK or unique combination");

		if (!ProcessedItems.Any(_=>_.Equals(parent)))
			{
			var fields = SqlHelper.NotIdentityFields(parent);
#>
		declare <#+ Write(string.Format("{0} {1}\n",parent.GetPKVarName(), parent.PkField.MetaData.SqlType));
			#>
<#+
#>		<#+	IfNotExists(parent);
#>			begin 
<#+
				if (parent.IsNumericPK)
				{
					if (parent.IsIdentityPK)
					{
						InsertValues(fields,parent.TableName);
#>
		set <#= parent.GetPKVarName()#> = SCOPE_IDENTITY()
<#+
						
					}
					else 
					{
#>
				select <#=parent.GetPKVarName()#> = max(<#=parent.PkField.FieldName#>)+1 from <#=parent.TableName
				#>
				select <#=parent.GetPKVarName()#> = isnull(<#=parent.GetPKVarName()#>, 1)

		<#+InsertValues(SqlHelper.InjectSqlVariable(fields,parent.GetPKVarName(),parent.PkField.FieldName),parent.TableName);				
					}
				}
				else
				{
					InsertValues(fields,parent.TableName);
#>
		set <#+ Write(parent.GetPKVarName());#> = <#+Write(parent.PkField.ValueToSqlString());
				}
#>
			end
			else 
			begin
				update <#=parent.TableName#> 
				set <#=SqlHelper.GetNameValueForUpdateString(fields.Where(_ => !_.MetaData.IsPK))#> 
				where <#=parent.GetUniqueSqlWhere()#> 

				select <#=parent.GetPKVarName()#> = <#=parent.PkField.FieldName#> 
				from <#=parent.TableName#> 
				where <#=parent.GetUniqueSqlWhere()#> 

			end <#+

			ProcessedItems.Add(parent);
			}
	}
 	
	void GenerateSql(PRecord child,PRecord parentRecord, PDependentTable FK)
	{
		if (!ProcessedItems.Any(_=>_.Equals(child)))
			{

		var fields = SqlHelper.NotIdentityFields(child);
	
		#>
		declare <#+ Write(string.Format("{0} {1}\n",child.GetPKVarName(), child.PkField.MetaData.SqlType));
		
		if (child.IsStartingPoint
			&& !string.IsNullOrEmpty(child.GetUniqueSqlWhere()))
		{ 
			IfNotExists(child);
#>
		begin
<#+
		}
		else if (child.UniqueFields.Any())
		{#>
			if not exists(select * from <#=string.Format("{0} where {1}",child.TableName,child.GetUniqueSqlWhere())#> ) 
			begin
<#+
		}

		if (!child.PkField.MetaData.IsIdentity
					&& child.PkField.MetaData.FieldType.IsNumericType()
						&& !child.SqlBuildStrategy.AsIsInserts) 
		{
#>
		select <#=child.GetPKVarName()#> = max(<#=child.PkField.FieldName#>)+1 from <#=child.TableName
		#>
		select <#=child.GetPKVarName()#> = isnull(<#=child.GetPKVarName()#>, 1)

<#+InsertValues(SqlHelper.InjectSqlVariable(fields,child.GetPKVarName(),child.PkField.FieldName),child.TableName);
		}
		else if (child.PkField.MetaData.IsIdentity)
			{
			InsertValues(fields,child.TableName); 
#>
		set <#=child.GetPKVarName()#> = SCOPE_IDENTITY()
<#+  
			}
			else
			{
				InsertValues(fields,child.TableName);#>
		set <#+ Write(child.GetPKVarName());#> = <#+Write(child.PkField.ValueToSqlString());
			}
	  if (child.IsStartingPoint
				&& !string.IsNullOrEmpty(child.GetUniqueSqlWhere()))
		{ 			
#>
		
		end
	else 
<#+ if (!child.SqlBuildStrategy.ThrowExecptionIfNotExists)
	{#>
		begin
			update <#=child.TableName#> 
			set <#=SqlHelper.GetNameValueForUpdateString(fields.Where(_ => !_.MetaData.IsPK))#> 
			where <#=child.GetUniqueSqlWhere()#> 

			select <#=child.GetPKVarName()#> = <#=child.PkField.FieldName#> 
			from <#=child.TableName#> 
			where <#=child.GetUniqueSqlWhere()#> 
		end 
<#+ }
	else 
	{
#>
		RAISERROR('Record from table <#=child.TableName#> with unique values <#=SqlHelper.GetNameNormalValueString(child.GetUniqueFields())#> is already in DB, can not insert!', 16, 1) 	
<#+
	}

		}
		else 
			if (child.UniqueFields.Any())
				WriteLine("			End");
	  WriteLine("");
	  ProcessedItems.Add(child);
	  }
	}
#>