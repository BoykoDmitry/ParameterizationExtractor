<#@ template debug="true" hostspecific="false" language="C#" #>
<#@ output extension=".cs" #>
<#@ assembly name="System.Core" #>
<#@ assembly name="netstandard" #>
<#@ assembly name="System.CodeDom" #>
<#@ assembly name="ParameterizationExtractor" #>
<#@ import namespace="System.Globalization" #>  
<#@ import namespace="System.Linq" #>
<#@ import namespace="System.Text" #>
<#@ import namespace="System.Collections.Generic" #>
<#@ import namespace="Quipu.ParameterizationExtractor.Logic.Model" #>
<#@ import namespace="Quipu.ParameterizationExtractor.Logic.Helpers" #>
<#@ import namespace="Quipu.ParameterizationExtractor.Logic.Interfaces" #>
<#@ import namespace="ParameterizationExtractor" #>
<#@ import namespace="Microsoft.Extensions.Logging"#>
<#@ import namespace="System.Reflection" #>
/*
Autogenerated by excavator tool, version <#=Assembly.GetExecutingAssembly().GetName().Version.ToString()#> 
<#=DateTime.Now.ToString()#>
Source: <#=Schema?.DataSource#> 
Database: <#=Schema?.Database#> 
*/ 
<#if (!String.IsNullOrEmpty(Config?.ResultingScriptOptions?.TargetDatabase))
{
	WriteLine("use {0}", Config?.ResultingScriptOptions?.TargetDatabase);
} 
#>

<#if (DeleterNeeded) 
	{
#>
/*
column + value

@_table
PKColumn|PKBinValue
**
**

for each row in @_table
- delete all children
- delete row
 */
if object_id('dbo.Deleter', 'P') is not null
exec ('drop procedure dbo.Deleter')
go
set ansi_nulls on
go
set quoted_identifier on
go

create procedure dbo.Deleter
  @Action			tinyint = null
, @TableName		nvarchar(128)/*full qualified table name eg dbo.Users or adm.Indexes. Without brackets [ ] */
, @ColumnName		nvarchar(128)
, @ColumnBinValue	varbinary(512)/*converted to nvarchar value*/
, @IsDebug		tinyint = 0 /*0-prod, 1-noexec, 2-extended msgs*/
, @Err_msg		nvarchar(2048) = null output
, @Err_nmbr		int = 0 output
/*with recompile*/
as
--#region changes description
/*
* Created by <ezhovea>; CreationDate <21.11.2020>
* Modifications:
* 1: Author <ezhovea>; ModificationDate <20200212>;
*	@TablesToExclude added
*		...
*/
--#endregion
--#region called by
/* -- list or modules, from which sp's calling
* 
* */
--#endregion
set nocount on;
-- set xact_abort on;
-- set fmtonly off;
--#region Local variables
declare
  @_TranCount	tinyint
, @_Err_svrt	int
, @_ProcName	sysname
, @_msg			nvarchar(2048)

, @_stmt		nvarchar(max)
, @_object_id	int
, @_PKColumnName	nvarchar(128)
, @_PKSysTypeId	tinyint
, @_Delimiter	nchar(1)
, @_ReferencedTableName	nvarchar(128)
, @_ReferencedColumn	nvarchar(128)
, @_cPKBinValue	varbinary(512)
, @_id int

;
select
  @_TranCount	= @@TRANCOUNT
, @_ProcName	= object_name(@@PROCID)
, @IsDebug		= isnull(@IsDebug, 0)
, @_Delimiter	= N';'
--#endregion
begin
	begin try
	if @IsDebug > 0
	begin
		select @_msg = replicate('- ', @@NESTLEVEL)
			+ @_ProcName + ' has started; @TableName='
			+ @TableName + '; @ColumnName='
			+ @ColumnName + '; @ColumnValue='
			+ convert(nvarchar(512), @ColumnBinValue, 1);
		set @_msg = isnull(@_msg, 'null')
		raiserror (@_msg, 10, 1) with nowait;
	end;
	if (@_TranCount = 0) begin transaction;
		
--#region checks and init
		select @_object_id = object_id(@TableName);
		if @_object_id is null
		begin
			select @_msg = replicate('- ', @@NESTLEVEL) + N'Cannot find an object ' + isnull(@TableName, 'null');
			raiserror (@_msg, 15, 1) with nowait;
		end;

		if @IsDebug > 0
		begin
			select @_msg = replicate('- ', @@NESTLEVEL) + '@_object_id = ' + isnull(cast(@_object_id as nvarchar(2048)), 'null');
			raiserror (@_msg, 10, 1) with nowait;
		end;

		select top (1)
		  @_PKColumnName = c.[name]
		, @_PKSysTypeId = t.system_type_id
		from sys.objects o
		inner join sys.indexes i on i.[object_id] = o.[object_id]
		inner join sys.index_columns ic on ic.[object_id] = i.[object_id]
			and ic.index_id = i.index_id
			and ic.is_included_column = 0
		inner join sys.[columns] c on c.[object_id] = ic.[object_id]
			and ic.column_id = c.column_id
		inner join sys.types t on t.system_type_id = c.system_type_id
			and t.user_type_id = c.user_type_id
		where
			o.[object_id] = @_object_id
		and o.[type] = 'U' /*U-user table*/
		and i.[type] in (1, 2) /*1-Clustered,2-Nonclustered*/
		and	(i.is_primary_key = 1
			or i.is_unique_constraint = 1
			or i.is_unique = 1
		)
		and i.is_disabled = 0
		and i.is_hypothetical = 0
		and i.filter_definition is null
		and 
		(
			select count(*) from sys.index_columns ic2
			where ic2.[object_id] = i.[object_id]
			and ic2.index_id = i.index_id
			and ic2.is_included_column = 0
		) = 1 /*single-columns indexes only*/
		order by
		  ic.key_ordinal /*key_ordinal = 1 means that it is a leading column in index key */
		, case
		    when i.is_primary_key = 1 then 10
		    when i.is_unique_constraint = 1 then 20
		    when i.is_unique = 1 then 30
		    when c.is_identity = 1 then 40
		    else 99
		end
		
		if @_PKColumnName is null /*if there are no PK, UQ - try to use identity*/
		select top (1) @_PKColumnName = c.[name]
		from sys.[columns] c
		where c.[object_id] = @_object_id and c.is_identity = 1
		  
		if @_PKColumnName is null
		begin
			select @_msg = replicate('- ', @@NESTLEVEL) + N'Cannot find a row identifier for table: ' + isnull(@TableName, 'null');
			raiserror (@_msg, 15, 1) with nowait;
		end;
		
		if @IsDebug > 0
		begin
			select @_msg = replicate('- ', @@NESTLEVEL) + '@_PKColumnName = ' + isnull(@_PKColumnName, 'null');
			raiserror (@_msg, 10, 1) with nowait;
		end;
--#endregion
--#region #PKValues
		/*attempt to find an PK(UQ, identity, unique index for given row)*/
		if object_id('tempdb..#PKValues') is null
		begin
			create table #PKValues
			( TableName		nvarchar(128)
			, PKColumnName	nvarchar(128)
			, PKBinValue	varbinary(512)
			, PK_SysTypeId	tinyint
			, NestLevel		tinyint
			, IsProcessed	bit not null default(0)
			, _id			int not null identity(1, 1)
			);
			
			select * from sys.types t
			create clustered index ixC on #PKValues(TableName, PKColumnName, _id);
		end;
		
		select @_stmt =
'insert into #PKValues(TableName, PKColumnName, PKBinValue, PK_SysTypeId, NestLevel)
select '''+@TableName+''', '''+@_PKColumnName+''', cast('+@_PKColumnName+' as varbinary(512)), '+cast(@_PKSysTypeId as nvarchar(max))+', @@nestlevel
from '+@TableName+' where cast('+@ColumnName+' as varbinary(512)) = @p_PKBinValue'

		if @IsDebug > 0
			raiserror (@_stmt, 10, 1) with nowait;

		exec sp_executesql
		  @stmt = @_stmt
		, @params = N'@p_PKBinValue varbinary(512)'
		, @p_PKBinValue = @ColumnBinValue;
--#endregion

		if @IsDebug = 1
			select TableName, PKColumnName, cast(PKBinValue as int) as binval, NestLevel , IsProcessed, _id
			  from #PKValues order by _Id

		declare @_curPK cursor
		set @_curPK = cursor local fast_forward for
			select p.PKBinValue, p._id
			from #PKValues p
			where p.TableName = @TableName
			and p.PKColumnName = @_PKColumnName
			and p.NestLevel = @@NESTLEVEL + 2 /*2 = (1 (procedure) + 1 (sp_executesql))*/
		open @_curPK;
		fetch next from @_curPK into @_cPKBinValue, @_id
		while @@fetch_status = 0
		begin
		--#region delete children if exists
			if @IsDebug > 0
			begin
				select @_msg = replicate('- ', @@NESTLEVEL) + N'delete children if exists for row: '
				+ @_PKColumnName + '=' + convert(nvarchar(512), @_cPKBinValue, 1);
				raiserror (@_msg, 10, 1) with nowait;
			end;
		
			declare @_curFK cursor
			set @_curFK = cursor local fast_forward for
			/*foreign keys, which refers to the mentioned column in the @TableName table*/
			select
			  s.[name] + '.' + o.[name] as ChildTableName
			, c.[name] as ChildRefColumn
			/*  s_ref.[name] + '.' + o_ref.[name] as ReferencedTableName
			, c_ref.[name] as ReferencedColumn*/
			from sys.foreign_keys fk
			inner join sys.objects o on fk.parent_object_id = o.[object_id]
			inner join sys.schemas s on s.[schema_id] = o.[schema_id]
			inner join sys.foreign_key_columns fkc on fkc.constraint_object_id = fk.[object_id]
			inner join sys.columns c on c.[object_id] = fkc.parent_object_id
				and c.column_id = fkc.parent_column_id

			inner join sys.objects o_ref on fk.referenced_object_id = o_ref.[object_id]
			inner join sys.schemas s_ref on s_ref.[schema_id] = o_ref.[schema_id]
			inner join sys.foreign_key_columns fkc_ref on fkc_ref.constraint_object_id = fk.[object_id]
			inner join sys.columns c_ref on c_ref.[object_id] = fkc.referenced_object_id
				and c_ref.column_id = fkc.referenced_column_id
			where o_ref.[object_id] = @_object_id
			and c_ref.[name] = @_PKColumnName
			/*and not exists(select * from @ListOfTablesToExclude LE where LE.TableName = s.[name] + '.' + o.[name])*/
			open @_curFK;
			
			fetch next from @_curFK into @_ReferencedTableName, @_ReferencedColumn
			
			while @@fetch_status = 0
			begin
			
				exec dbo.Deleter
				  @TableName = @_ReferencedTableName
				, @ColumnName = @_ReferencedColumn
				, @ColumnBinValue = @_cPKBinValue
				, @IsDebug = @IsDebug;
			
				fetch next from @_curFK into @_ReferencedTableName, @_ReferencedColumn
			end;
			
			close @_curFK;
			deallocate @_curFK;
		--#endregion

			select @_stmt =
			'delete from '+@TableName+' where cast('+@_PKColumnName+' as varbinary(512)) = @p_PKBinValue'
			if @IsDebug > 0
				begin
					select @_msg = 
					'delete from '+@TableName+' where '+@_PKColumnName+' = '+
					case
						when @_PKSysTypeId in (35, 175, 231, 239, 231)
							then ' ''' + cast(@_cPKBinValue as nvarchar(max)) + ''' '
						when @_PKSysTypeId in (48, 52, 56) then ' ''' + cast(cast(@_cPKBinValue as int) as nvarchar(2048)) + ''' '
						when @_PKSysTypeId in (58, 61) then ' ''' + cast(cast(@_cPKBinValue as datetime) as nvarchar(2048)) + ''' '
						else '@p_PKBinValue'
					end
					
					select @_msg = replicate('- ', @@NESTLEVEL) + 'delete row : ' + isnull(@_msg, 'null');
					raiserror (@_msg, 10, 1) with nowait;
				end;
			if @IsDebug != 1
			begin
			/*disable triggers*/
				exec sp_executesql
				  @stmt = @_stmt
				, @params = N'@p_PKBinValue varbinary(512)'
				, @p_PKBinValue = @_cPKBinValue;
			/*enable triggers back*/
			end;
			fetch next from @_curPK into @_cPKBinValue, @_id
		end;
		
		close @_curPK;
		deallocate @_curPK;		

	if (@_TranCount = 0) commit;
	return isnull(@Err_nmbr, 0);	
	end try
--#region catch
	begin catch
		select
		  @Err_msg = isnull(error_message(), 'has not been retrieved')
		, @Err_nmbr = error_number()
		, @_Err_svrt = error_severity();
		if (@_TranCount = 0 and @@trancount > 0) rollback;
		-- print 'Catch section in module : '+isnull(@_ProcName, 'Not defined') + ' Error:'+ @Err_msg;
		select @Err_msg = 'Catch section in module: '+isnull(@_ProcName, 'Not defined') + ' Error: '+ @Err_msg;
		raiserror (@Err_msg, @_Err_svrt, 1) with nowait;
	end catch;
--#endregion
	return isnull(@Err_nmbr, 0);
end;
go

<# 
	}
#>

GO
set nocount on
go
set ansi_nulls on
go
set quoted_identifier on
go  

begin try
begin tran
<# 	
foreach (var record in Items.Where(_ => _.IsStartingPoint))
            {
#>
<#
#>
	--#region <#=record.TableName#>
<#
	if (record.SqlBuildStrategy.AsIsInserts)
	{
#>
	alter table <#=record.TableName#> disable trigger all
<#
    }
				//ProcessedItems = new List<PRecord>();
				ProcessOne(record, null, null);
	if (record.SqlBuildStrategy.AsIsInserts)
	{
#>
	alter table <#=record.TableName#> enable trigger all
<#
	}
#>
	--#endregion <#=record.TableName#>
<#
            }
#>

<# if ((Config?.ResultingScriptOptions?.Rollback).GetValueOrDefault())
	WriteLine("rollback");
   else
	WriteLine("commit");
#>

end try
--#region catch
begin catch
	declare @Err_msg nvarchar(2048), @Err_svrt int
	select @Err_msg = isnull(error_message(), 'has not been retrieved'), @Err_svrt = error_severity();
	if @@trancount > 0 rollback;
	raiserror (@Err_msg, @Err_svrt, 1) with nowait;
end catch;

<#if (DeleterNeeded) 
	{
#>
if object_id('dbo.Deleter', 'P') is not null
	exec ('drop procedure dbo.Deleter')
<#
	}
#>
--#endregion


<#+ 
	private T GetObjectFromSession<T>(string key)
		where T: class
	{
		object obj = null;
		this.Session.TryGetValue(key,out obj);

		return obj as T;
	}

	private IList<PRecord> ProcessedItems = new List<PRecord>();

	private IExtractConfiguration _config;
	private IExtractConfiguration Config
	{
		get {
			

			_config = _config ?? GetObjectFromSession<IExtractConfiguration>("config") ?? new GlobalExtractConfiguration();
			return _config;
		}
	}
	
	private bool DeleterNeeded
	{
		get {
			object b = false;
			this.Session.TryGetValue("DeleterNeeded",out b);

			return (bool)b;
		}
	}

	private ISourceSchema _schema;
	private ISourceSchema Schema
	{
		get {
			_schema = _schema ?? GetObjectFromSession<ISourceSchema>("schema") ?? new StubSourceSchema();

			return _schema;
		}
	} 

	private ILogger _log;
	private ILogger Log
	{
		get {
			_log = _log ?? GetObjectFromSession<ILogger>("log");

			return _log;
		}
	} 

	private IEnumerable<PRecord> _items;
	private IEnumerable<PRecord> Items
	{
		get {
			_items = _items ?? GetObjectFromSession<IEnumerable<PRecord>>("source") ?? new List<PRecord>();

			return _items;
		}
	} 

	void ProcessOne (PRecord item, PRecord parentRecord, PDependentTable FK, IList<PRecord> moves = null )
	{
		//Console.WriteLine("Process one entry:{0}, parentRecord:{1}",item.ToString(), parentRecord?.ToString());
		moves = moves ?? new List<PRecord>();
		if (moves.Any(_=>_.Equals(item)))
		{
			//Console.WriteLine("Shit hits the fan !");
			return;
		}

		moves.Add(item);

		
		if (item.Parents.Any())
		{
			//foreach(var parent in item.Parents)
			//	Console.WriteLine("item.Parent {0}", parent.PRecord);
								
			foreach(var parent in item.Parents)
			{						
				if (!ProcessedItems.Any(_=>_.Equals(parent.PRecord))
					&& !moves.Any(_=>_.Equals(parent.PRecord))
				)
				{
					Log.LogDebug("item.Parents, parentRecord:{0}",parent.PRecord?.ToString());
					if (parent.PRecord.SqlBuildStrategy.NoInserts)
					{
						if (parent.PRecord.SqlBuildStrategy.ThrowExecptionIfNotExists)
						{
							IfNotExists(parent.PRecord);
							#>
		RAISERROR('Record from table <#=parent.PRecord.TableName#> with unique values <#=SqlHelper.GetNameNormalValueString(parent.PRecord.GetUniqueFields())#> can not be found', 16, 1) 
<#+
						}

						GenerateSqlForNoExtractionTable(parent.PRecord);						
					}
					else
					{
						//Console.WriteLine("I am going to print GenerateSqlForParent, parentRecord:{0} item {1}",parent.PRecord?.ToString(), item);						
						GenerateSqlForParent(parent.PRecord);						
					}
						
					//foreach(var c in parent.PRecord.Childern)
						//Console.WriteLine("parent.PRecord.Childern {0}", c.PRecord);

					foreach(var c in parent.PRecord.Childern.Where(_=>!moves.Any(t=>t.Equals(_.PRecord))))
					{
						//Console.WriteLine("Process parent children:{0}, parentRecord:{1}",c.PRecord.ToString(), parent.PRecord?.ToString());
						ProcessOne (c.PRecord, parent.PRecord, c.FK,moves);
					}
				}

				SqlHelper.PrepareFieldsForChild(item, parent.PRecord.GetPKVarName(), parent.FK);				
			}
		}

		if (parentRecord != null && FK != null)
			SqlHelper.PrepareFieldsForChild(item, parentRecord.GetPKVarName(), FK);


		GenerateSql(item,parentRecord,FK);

		foreach (var child in item.Childern.Where(_=>!moves.Any(t=>t.Equals(_.PRecord))))
		{
            ProcessOne(child.PRecord, item, child.FK, moves);
			Write("\n");
		}
	}

	void InsertValues(IEnumerable<PField> fields, string tableName)
	{
#>
		insert into <#=tableName#> (<#+Write(string.Join(",",fields.Select(_=>string.Format("[{0}]",_.FieldName))));#>) 
		values (<#=string.Join(",",fields.Select(_=>_.ValueToSqlString()))#>)
<#+
	}

	void IfNotExists(PRecord table)
	{
		if (!string.IsNullOrEmpty(table.GetUniqueSqlWhere()))
		{
#>
		if not exists(select * from <#=string.Format("{0} where {1}",table.TableName,table.GetUniqueSqlWhere())#> )				
<#+		}
	else #> 
	-- here should be something like if not exists, but unique columns(or values) can not be found. 
<#+
	}
    
    void GenerateSqlForNoExtractionTable(PRecord parent)
	{
		if (!ProcessedItems.Any(_=>_.Equals(parent)))
			{
	#>
		declare <#=string.Format("{0} {1}\n",parent.GetPKVarName(), parent.PkField.MetaData.SqlType)#> 
		select <#=parent.GetPKVarName()#> = <#=parent.PkField.FieldName#> 
		from  <#=parent.TableName#>  
		where <#=parent.GetUniqueSqlWhere()#>
<#+
		ProcessedItems.Add(parent);
		}		
	}

	void GenerateSqlForParent(PRecord parent)
	{
		if (!parent.GetUniqueFields().Any())
			Error("Can not generate sql without PK or unique combination");

		if (!ProcessedItems.Any(_=>_.Equals(parent)))
			{
			var fields = SqlHelper.NotIdentityFields(parent);
#>
		declare <#+ Write(string.Format("{0} {1}\n",parent.GetPKVarName(), parent.PkField.MetaData.SqlType));
			#>
<#+	if (parent.SqlBuildStrategy.DeleteExistingRecords) 
	{ 
	  #>
	declare <#+ Write(string.Format("{0}_data {1}\n",parent.GetPKVarName(), parent.PkField.MetaData.SqlType));#>
	select  <#=parent.GetPKVarName()#>_data  = <#=parent.PkField.FieldName#> 
	from <#=parent.TableName#>
	where <#=parent.GetUniqueSqlWhere()#> 

	declare <#=parent.GetPKVarName()#>_valbinary varbinary(512)
	set <#=parent.GetPKVarName()#>_valbinary = cast( <#=parent.GetPKVarName()#>_data  as varbinary)

	exec Deleter @TableName = '<#=parent.TableName#>', @ColumnName='<#=parent.PkField.FieldName#>', @ColumnBinValue =  <#=parent.GetPKVarName()#>_valbinary


<#+
	} #>

<#+
#>		<#+	IfNotExists(parent);
#>			begin 
<#+
				if (parent.IsNumericPK)
				{
					if (parent.IsIdentityPK)
					{

						if (parent.SqlBuildStrategy.IdentityInsert)
							{
#>
				    SET IDENTITY_INSERT <#=parent.TableName#> ON; 
<#+
								InsertValues(parent,parent.TableName); 
#>
								select <#=parent.GetPKVarName()#> = <#=parent.PkField.FieldName#> 
								from <#=parent.TableName#> 
								where <#=parent.PkField.FieldName#> = <#=parent.PkField.Value#> 

					SET IDENTITY_INSERT <#=parent.TableName#> OFF; 
<#+
							}
					    else 
							{

						InsertValues(fields,parent.TableName);
#>
		set <#= parent.GetPKVarName()#> = SCOPE_IDENTITY()
<#+
						
							}
					}
					else 
					{
#>
				select <#=parent.GetPKVarName()#> = max(<#=parent.PkField.FieldName#>)+1 from <#=parent.TableName
				#>
				select <#=parent.GetPKVarName()#> = isnull(<#=parent.GetPKVarName()#>, 1)

		<#+InsertValues(SqlHelper.InjectSqlVariable(fields,parent.GetPKVarName(),parent.PkField.FieldName),parent.TableName);				
					}
				}
				else
				{
					InsertValues(fields,parent.TableName);
#>
		set <#+ Write(parent.GetPKVarName());#> = <#+Write(parent.PkField.ValueToSqlString());
				}
#>
			end
<#+ if (!parent.SqlBuildStrategy.DeleteExistingRecords) 
	{ 
#>
			else 
			begin
				update <#=parent.TableName#> 
				set <#=SqlHelper.GetNameValueForUpdateString(fields.Where(_ => !_.MetaData.IsPK))#> 
				where <#=parent.GetUniqueSqlWhere()#> 

				select <#=parent.GetPKVarName()#> = <#=parent.PkField.FieldName#> 
				from <#=parent.TableName#> 
				where <#=parent.GetUniqueSqlWhere()#> 

			end 
<#+ } #>
<#+

			ProcessedItems.Add(parent);
			}
	}
 	
	void GenerateSql(PRecord child,PRecord parentRecord, PDependentTable FK)
	{
		if (!ProcessedItems.Any(_=>_.Equals(child)))
			{

		var fields = SqlHelper.NotIdentityFields(child);
		
		#>
<#+ if (!child.IsCompositePK) 
	{ 
#>
		declare <#+ Write(string.Format("{0} {1}\n",child.GetPKVarName(), child.PkField.MetaData.SqlType));#>
<#+
	}
#>
<#+	if (child.SqlBuildStrategy.DeleteExistingRecords) 
	{ 
	  #>
	declare <#+ Write(string.Format("{0}_data {1}\n",child.GetPKVarName(), child.PkField.MetaData.SqlType));#>
	select <#=child.GetPKVarName()#>_data = <#=child.PkField.FieldName#> 
	from <#=child.TableName#>
	where <#=child.GetUniqueSqlWhere()#> 

	declare <#=child.GetPKVarName()#>_valbinary varbinary(512)
	set <#=child.GetPKVarName()#>_valbinary = cast( <#=child.GetPKVarName()#>_data  as varbinary)

	exec Deleter @TableName = '<#=child.TableName#>', @ColumnName='<#=child.PkField.FieldName#>', @ColumnBinValue =  <#=child.GetPKVarName()#>_valbinary


<#+
	} #>		
<#+		if (child.IsStartingPoint
			&& !string.IsNullOrEmpty(child.GetUniqueSqlWhere()))
		{ 
			IfNotExists(child);
#>
		begin
<#+
		}
		else if (child.UniqueFields.Any())
		{#>
			if not exists(select * from <#=string.Format("{0} where {1}",child.TableName,child.GetUniqueSqlWhere())#> ) 
			begin
<#+
		}

		if (!child.PkField.MetaData.IsIdentity
					&& child.IsNumericPK
						&& !child.SqlBuildStrategy.AsIsInserts) 
		{
#>
		select <#=child.GetPKVarName()#> = max(<#=child.PkField.FieldName#>)+1 from <#=child.TableName
		#>
		select <#=child.GetPKVarName()#> = isnull(<#=child.GetPKVarName()#>, 1)

<#+InsertValues(SqlHelper.InjectSqlVariable(fields,child.GetPKVarName(),child.PkField.FieldName),child.TableName);
		}
		else if (child.PkField.MetaData.IsIdentity)
			{
				if (child.SqlBuildStrategy.IdentityInsert)
				{
#>
				    SET IDENTITY_INSERT <#=child.TableName#> ON; 
<#+
					InsertValues(child,child.TableName);  
#>
					select <#=child.GetPKVarName()#> = <#=child.PkField.FieldName#> 
					from <#=child.TableName#> 
					where <#=child.PkField.FieldName#> = <#=child.PkField.Value#> 

					SET IDENTITY_INSERT <#=child.TableName#> OFF; 
<#+
				}
				else 
				{
					InsertValues(fields,child.TableName); 
#>
<#+ if (!child.IsCompositePK) 
	{ 
#>
		set <#=child.GetPKVarName()#> = SCOPE_IDENTITY()
<#+
	}
#>
<#+  
				}
			}
			else
			{
				InsertValues(fields,child.TableName);#>
<#+ if (!child.IsCompositePK) 
	{ 
#>
		set <#+ Write(child.GetPKVarName());#> = <#+Write(child.PkField.ValueToSqlString());
	}
			}
	  if (child.IsStartingPoint
				&& !string.IsNullOrEmpty(child.GetUniqueSqlWhere()))
		{ 			
#>
		
		end
	else 
<#+ if (!child.SqlBuildStrategy.ThrowExecptionIfNotExists && !child.SqlBuildStrategy.DeleteExistingRecords)
	{#>
		begin
			update <#=child.TableName#> 
			set <#=SqlHelper.GetNameValueForUpdateString(fields.Where(_ => !_.MetaData.IsPK))#> 
			where <#=child.GetUniqueSqlWhere()#> 
<#+ if (!child.IsCompositePK) 
	{ 
#>
			select <#=child.GetPKVarName()#> = <#=child.PkField.FieldName#> 
			from <#=child.TableName#> 
			where <#=child.GetUniqueSqlWhere()#> 
<#+
	}
#>
		end 
<#+ }
	else 
	{
#>
		RAISERROR('Record from table <#=child.TableName#> with unique values <#=SqlHelper.GetNameNormalValueString(child.GetUniqueFields())#> is already in DB, can not insert!', 16, 1) 	
<#+
	}

		}
		else 
			if (child.UniqueFields.Any())
			{
				WriteLine("			End ");
				#>
<#+ if (!child.IsCompositePK) 
	{ 
#>
			select <#=child.GetPKVarName()#> = <#=child.PkField.FieldName#> 
			from <#=child.TableName#> 
			where <#=child.GetUniqueSqlWhere()#> 
				<#+
	  }
			}
	  WriteLine("");
	  ProcessedItems.Add(child);
	  }
	}
#>
